//! 5000-500 = 4500. 4.5초 이후에 isFading 을 true 로 최신화 한다.

//! 5초가 지난 후 callback 실행하여 dequeueNotification 의 리턴값을 reducer 에 전달.

//! CSS 부분

//! Dispatch() 는 Action 객체(return값)를 Reducer 로 전달해주는 메소드.

//! Toast 로부터 dismisstime 을 받는다.

//! action 의 type(ADD_TO_CART 등) 에 따라서 특정 동작을 수행한다. => 특정 동작? state 를 변경해주는 것.

//! action.payload { message, dismissTime, uuid, },

//! action.payload.itemId = 번호.

//! className fade-out 이 추가되면 2초 동안 opacity를 0으로 만든다.

//! dispatch 의 return 값을 notificationReducer 에 전달한다.

//! div 의 클래스이름에 fade-out 이 생겨 CSS의 사라지는 효과가 실행된다.

//! immutability 를 위해, shallow copy 한다.

//! notification 중 가장 첫번째 요소를 제거한 새로운 배열로 상태를 변경한다.

//! notificationReducer 로 데이터가 최신화되었기 때문에 state.notificationReducer 로 데이터를 가져온다.

//! shallow copy 를 해야 원본 손실이 발생하지 않는다.

//! test case 에서는 payload를 return 안에 넣어서 문제를 해결하길 바란다.

//! type 과 payload(quantity, id) 등을 받아와 아래 동작을 수행.

//! useSelector 와 userDispatch 를 어떤 컴포넌트에 사용해야 하는지?

//! 기존의 initialState 의 notification 에 새로운 액션 내용을 추가한다.

//! 비동기 함수인 notify 는 비동기 상황을 구현한 뒤 dispatch를 통해 다른 동기 액션을 호출한다.

//! 여기서 다른 동기 액션이란 enqueueNotification, dequeueNotification
